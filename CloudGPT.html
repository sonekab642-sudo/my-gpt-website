<!DOCTYPE html>
<html lang="bn">
<head>
<meta charset="UTF-8">
<title>CloudGPT (WhatsApp Style) - Gemini</title>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #e5ddd5;
  }
  header {
    background: #075e54;
    color: white;
    padding: 10px 15px;
    font-size: 18px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #chatbox {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    display: flex;
    flex-direction: column;
  }
  .msg {
    max-width: 70%;
    margin: 6px 0;
    padding: 10px;
    border-radius: 10px;
    line-height: 1.4;
    word-break: break-word;
    box-shadow: 0 1px 0 rgba(0,0,0,0.05);
  }
  .user { background: #dcf8c6; align-self: flex-end; }
  .bot  { background: #ffffff; align-self: flex-start; }

  /* timestamp */
  .timestamp {
    font-size: 10px;
    color: #555;
    margin-top: 4px;
    text-align: right;
  }

  footer {
    display: flex;
    padding: 10px;
    background: #f0f0f0;
    align-items: center;
    gap: 4px;
  }
  textarea {
    flex: 1;
    resize: none;
    padding: 4px 14px;
    border: 1px solid #ccc;
    border-radius: 20px;
    font-size: 14px;
    outline: none;
    min-height: 40px;
    max-height: 140px;
    overflow-y: auto;
  }
  .iconBtn {
    background: #128c7e;
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    width: 44px;
    height: 44px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 22px;
  }
  .iconBtn:hover { background: #0d6f63; }
  .clearBtn {
    background: #d9534f;
    border: none;
    border-radius: 8px;
    padding: 6px 10px;
    font-size: 14px;
    color: white;
    cursor: pointer;
  }
  .clearBtn:hover { background: #b52b27; }
  #imageInput { display: none; }
  img.msg-image { max-width: 200px; border-radius: 10px; margin-top: 6px; display:block; }

  @media (max-width:420px){
    .msg { max-width: 85%; }
    .iconBtn { width:40px; height:40px; }
  }
</style>
</head>
<body>
<header>
  <span>CloudGPT</span>
  <button class="clearBtn" onclick="clearHistory()">Clear History</button>
</header>

<div id="chatbox"></div>

<footer>
  <button class="iconBtn" onclick="document.getElementById('imageInput').click()">
    <span class="material-icons">attach_file</span>
  </button>
  <input type="file" id="imageInput" accept="image/*">
  <textarea id="userInput" rows="1" placeholder="‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®..."></textarea>
  <button class="iconBtn" onclick="sendMessage()">
    <span class="material-icons">send</span>
  </button>
</footer>

<script>
const API_KEY = "AIzaSyBltW1uLp1CuHa_G9igYqFyzlsIt51pYAY";

/* IndexedDB setup */
let db;
let request = indexedDB.open("CloudGPT_DB", 1);
request.onupgradeneeded = function(e){
  db = e.target.result;
  if(!db.objectStoreNames.contains("messages")){
    db.createObjectStore("messages", { keyPath: "id", autoIncrement:true });
  }
};
request.onsuccess = function(e){ db = e.target.result; renderChat(); };
request.onerror = function(e){ console.error("IndexedDB Error:", e.target.error); };

function saveMessage(msg){ if(!db) return; let tx = db.transaction("messages","readwrite"); let store = tx.objectStore("messages"); store.add(msg); }
function getAllMessages(callback){ if(!db) return callback([]); let tx = db.transaction("messages","readonly"); let store = tx.objectStore("messages"); let all = store.getAll(); all.onsuccess = function(){ callback(all.result || []); }; all.onerror = function(){ callback([]); }; }
function updateMessage(msg){ if(!db) return; let tx = db.transaction("messages","readwrite"); let store = tx.objectStore("messages"); store.put(msg); }

/* render chat */
function renderChat(){
  getAllMessages(messages=>{
    const chatbox = document.getElementById("chatbox");
    chatbox.innerHTML = "";
    messages.forEach(msg=>{
      const div = document.createElement("div");
      div.className = "msg " + (msg.role==="user" ? "user" : "bot");

      // message text
      if(msg.text) {
        const p = document.createElement("div");
        p.innerText = msg.text;
        div.appendChild(p);
      }
      // image
      if(msg.image){
        const img = document.createElement("img");
        img.className = "msg-image";
        img.src = msg.image;
        div.appendChild(img);
      }

      // timestamp
      const ts = document.createElement("div");
      ts.className = "timestamp";
      ts.innerText = new Date(msg.createdAt).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
      div.appendChild(ts);

      chatbox.appendChild(div);
    });
    chatbox.scrollTop = chatbox.scrollHeight;
  });
}

/* convert file -> base64 */
function toBase64(file){
  return new Promise((resolve,reject)=>{
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = ()=>resolve(reader.result);
    reader.onerror = reject;
  });
}

/* send message */
async function sendMessage(){
  const input = document.getElementById("userInput");
  const fileInput = document.getElementById("imageInput");
  const userText = input.value.trim();
  if(!userText && fileInput.files.length === 0) return;

  let userMsg = { role: "user", createdAt: Date.now() };
  if(userText) userMsg.text = userText;

  if(fileInput.files.length > 0){
    const file = fileInput.files[0];
    const base64 = await toBase64(file);
    userMsg.image = base64;
    fileInput.value = "";
    if(!userText) userMsg.text = "üìé ‡¶õ‡¶¨‡¶ø ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá";
  }

  saveMessage(userMsg);
  renderChat();
  input.value = "";

  let botMsg = { role: "model", text: "‚è≥ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®...", createdAt: Date.now() };
  saveMessage(botMsg);
  renderChat();

  // prepare history
  getAllMessages(async (messages) => {
    let contents = messages.map(m => {
      let parts = [];
      if(m.text) parts.push({ text: m.text });
      if(m.image){
        let mimeMatch = m.image.match(/^data:(.*);base64,/);
        let mimeType = mimeMatch ? mimeMatch[1] : "image/png";
        parts.push({ inline_data: { mime_type: mimeType, data: m.image.split(",")[1] } });
      }
      return { role: m.role, parts: parts };
    });

    try{
      const res = await fetch(
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + API_KEY,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contents: contents })
        }
      );
      const data = await res.json();

      const text = data?.candidates?.[0]?.content?.parts?.map(p => p.text || "").join("\n") || "‚ö†Ô∏è Connection Problem";

      getAllMessages(all=>{
        let lastBot = all.filter(m=>m.role==="model").slice(-1)[0];
        if(lastBot){
          lastBot.text = text;
          updateMessage(lastBot);
          renderChat();
        }
      });

    }catch(err){
      console.error(err);
      getAllMessages(all=>{
        let lastBot = all.filter(m=>m.role==="model").slice(-1)[0];
        if(lastBot){
          lastBot.text = "‚ö†Ô∏è Error: " + (err.message || err);
          updateMessage(lastBot);
          renderChat();
        }
      });
    }
  });
}

document.getElementById('userInput').addEventListener('keydown', function(e){
  if(e.key === 'Enter' && !e.shiftKey){
    e.preventDefault();
    sendMessage();
  }
});

function clearHistory(){
  if(!db) return;
  let tx = db.transaction("messages","readwrite");
  let store = tx.objectStore("messages");
  store.clear();
  document.getElementById("chatbox").innerHTML = "";
}
</script>
</body>
</html>